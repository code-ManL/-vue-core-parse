{"code":"import { isObject } from '@vue/shared';\r\nimport { mutableHandlers, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHandlers } from './baseHandlers';\r\n/**\r\n *\r\n * 这个不仅仅是为了优化，一些场景有奇效，比如 reactive([{}]).includes(arr[0])\r\n * 由于includes内部会访问arr[0],然后和传入的arr[0]比较的时候，如果不用这个缓存，\r\n * 那么将是两个不同的代理对象,虽然这一步可以优化，但是由于 reactive([obj]) arr.includes(obj)\r\n * 会返回false的原因，不得不重写了includes，因此这里的优化在includes重新实现了\r\n *\r\n *  */\r\nconst reactiveMap = new WeakMap(); // 缓存代理过的target\r\n// 工厂函数\r\nexport function createReactiveObject(target, isReadonly, baseHandlers) {\r\n    // 判断传入的数据是否为对象\r\n    if (!isObject(target)) {\r\n        // __DEV__用于判断当前的代码编写环境为开发环境的时候，发出警告，因此在生产环境下这段代码为dead code，利用tree-shaking(依赖于ES Module)移除掉\r\n        if ('__DEV__') {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // 判断target是否被代理过，如果target是一个响应式对象，这里会触发getter(主要针对于target是一个响应式对象，如果target是原始对象不会触发getter，只有响应式对象才会触发getter)\r\n    // && 后面的 判断用于 readonly(reactive(obj)) 这样的情况\r\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] && !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\r\n        // console.log(isReadonly);\r\n        // console.log(target[ReactiveFlags.IS_REACTIVE]);\r\n        return target;\r\n    }\r\n    // 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象，简单的说就是代理过的对象不再重复代理，取出之前创建的代理对象返回\r\n    const existionProxy = reactiveMap.get(target);\r\n    if (existionProxy) {\r\n        return existionProxy;\r\n    }\r\n    const proxy = new Proxy(target, baseHandlers); // 数据劫持\r\n    reactiveMap.set(target, proxy); // 缓存\r\n    return proxy; // 返回代理\r\n}\r\nexport function shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers);\r\n}\r\nexport function reactive(target) {\r\n    return createReactiveObject(target, false, mutableHandlers);\r\n}\r\nexport function readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers);\r\n}\r\nexport function shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers);\r\n}\r\nexport function toRaw(observed) {\r\n    // 如果传入的对象是一个响应式对象,例如reactive代理的响应式对象,可以访问该代理对象的'__v_raw'属性,这个属性会返回代理对象的原始对象\r\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    // 如果这里获取到了原始对象,但是这个原始对象还可能是一个响应式对象,因此需要递归的去调用toRaw方法去获取原始对象,直到真正的获取到了原始对象\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nexport const toReactive = (value) => \r\n// 判断传入的原始数据是否为对象类型\r\n// 如果传入的原始数据是对象类型,那么调用reactive去进行代理,这里reactive内部其实也是进行了相关的优化,如果一个原始值已经是被代理过的,那么会直接返回已经代理的对象,就不用重新去代理了\r\n// 如果传入的原始数据不是对象类型,那么直接返回该数据\r\nisObject(value) ? reactive(value) : value;\r\n//# sourceMappingURL=reactive.js.map","references":["F:/forTest/v-rmake/packages/shared/src/index.ts","F:/forTest/v-rmake/packages/reactivity/src/baseHandlers.ts"],"map":"{\"version\":3,\"file\":\"reactive.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../packages/reactivity/src/reactive.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAA;AAEtC,OAAO,EAAE,eAAe,EAAE,gBAAgB,EAAE,uBAAuB,EAAE,uBAAuB,EAAE,MAAM,gBAAgB,CAAA;AAGpH;;;;;;;MAOM;AACN,MAAM,WAAW,GAAG,IAAI,OAAO,EAAe,CAAC,CAAC,eAAe;AAE/D,OAAO;AACP,MAAM,UAAU,oBAAoB,CAAC,MAAc,EAAE,UAAmB,EAAE,YAA+B;IAEvG,eAAe;IACf,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QACrB,2FAA2F;QAC3F,IAAI,SAAS,EAAE;YACb,OAAO,CAAC,IAAI,CAAC,kCAAkC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;SACjE;QACD,OAAO,MAAM,CAAA;KACd;IAED,6GAA6G;IAC7G,4CAA4C;IAC5C,IAAI,MAAM,mCAAmB,IAAI,CAAC,CAAC,UAAU,IAAI,MAAM,kDAA2B,CAAC,EAAE;QACnF,2BAA2B;QAC3B,kDAAkD;QAClD,OAAO,MAAM,CAAA;KACd;IAED,8EAA8E;IAC9E,MAAM,aAAa,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;IAE7C,IAAI,aAAa,EAAE;QACjB,OAAO,aAAa,CAAA;KACrB;IAED,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA,CAAC,OAAO;IAErD,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA,CAAC,KAAK;IACpC,OAAO,KAAK,CAAA,CAAC,OAAO;AACtB,CAAC;AAID,MAAM,UAAU,eAAe,CAAmB,MAAS;IACzD,OAAO,oBAAoB,CACzB,MAAM,EACN,KAAK,EACL,uBAAuB,CACxB,CAAA;AACH,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,MAAc;IACrC,OAAO,oBAAoB,CACzB,MAAM,EACN,KAAK,EACL,eAAe,CAChB,CAAA;AACH,CAAC;AAED,MAAM,UAAU,QAAQ,CAAmB,MAAS;IAClD,OAAO,oBAAoB,CACzB,MAAM,EACN,IAAI,EACJ,gBAAgB,CACjB,CAAA;AACH,CAAC;AAGD,MAAM,UAAU,eAAe,CAAmB,MAAS;IACzD,OAAO,oBAAoB,CACzB,MAAM,EACN,IAAI,EACJ,uBAAuB,CACxB,CAAA;AACH,CAAC;AAmBD,MAAM,UAAU,KAAK,CAAI,QAAW;IAClC,4EAA4E;IAC5E,MAAM,GAAG,GAAG,QAAQ,IAAK,QAAmB,mCAAmB,CAAA;IAC/D,0EAA0E;IAC1E,OAAO,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAA;AACpC,CAAC;AAED,MAAM,CAAC,MAAM,UAAU,GAAG,CAAoB,KAAQ,EAAK,EAAE;AAC3D,mBAAmB;AACnB,qGAAqG;AACrG,4BAA4B;AAC5B,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAA\"}"}
