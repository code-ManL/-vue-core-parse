{"code":"import { isArray, extend, isMap, isIntegerKey, toNumber } from '@vue/shared';\r\n/**\r\n * effect1(()=>{\r\n *    state.name\r\n *    effect2(()=>{\r\n *      state.age\r\n *    })\r\n *    state.slary\r\n * })\r\n *\r\n * effect1 -> name slary\r\n * effect2 -> age\r\n *\r\n * 用栈来处理，存储正确的关系\r\n */\r\nlet effectStack = [];\r\nexport let activeEffect;\r\nexport const ITERATE_KEY = Symbol('iterate');\r\nexport const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate');\r\nexport let shouldTrack = true;\r\nconst trackStack = [];\r\nexport function pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nexport function resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction cleanupEffect(effect) {\r\n    // deps 是当前副作用函数身上的一个属性，这个属性中存储了那些object.key收集了当前effect所对应的set集合\r\n    const { deps } = effect; // deps -> [set,set]\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            // 重新执行副作用函数的时候，将当前副作用函数从这个 deps 当中删除\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nexport class ReactiveEffect {\r\n    fn;\r\n    scheduler;\r\n    active = true;\r\n    deps = []; // 让 effect 记录他依赖了哪些属性，同时要记录当前属性依赖了哪个effect \r\n    parent = undefined;\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n    }\r\n    run() {\r\n        // 如果不是激活状态\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        /**\r\n         * 防止死循环，比如\r\n         * effect(()=>{\r\n         *    state.name = Math.Romdom()\r\n         * })\r\n         */\r\n        if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行 \r\n            try {\r\n                // 激活状态的话，需要建立属性和依赖的关系\r\n                cleanupEffect(this); // 清空分支切换时遗留的副作用函数\r\n                activeEffect = this;\r\n                effectStack.push(activeEffect);\r\n                return this.fn(); // 访问data的属性，触发getter （依赖收集）\r\n            }\r\n            finally {\r\n                effectStack.pop(); // 嵌套副作用函数执行完毕以后将最里层的副作用函数pop出去\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    }\r\n    // 清除依赖关系，可以手动调用stop执行\r\n    stop() {\r\n        if (this.active) // 如果effect是激活的采取将deps上的effect移除\r\n         {\r\n            cleanupEffect(this);\r\n            this.active = false; // 关闭当前effect的激活状态\r\n        }\r\n    }\r\n}\r\nconst targetMap = new WeakMap();\r\nexport function isTracking() {\r\n    return activeEffect !== undefined;\r\n}\r\n// 追踪 一个属性对应多个effect 多个属性对应一个effect\r\nexport function track(target, key, type) {\r\n    // 判断这个 state.name 访问属性的操作是不是在 effect 中执行的，简单来说就是判断需不需要收集\r\n    if (!isTracking() || !shouldTrack) { //如果这个属性不依赖于 effect 直接跳出\r\n        return;\r\n    }\r\n    // 根据 target 从 '桶' 当中取得depsMap ,他是一个 Map 类型: key -> effetcs\r\n    // 这行代码的含义就是从桶（大桶）当中拿出 target 对象所有字段的副作用函数集合（所有小桶）  \r\n    let depsMap = targetMap.get(target);\r\n    //如果当前target对象还没有它的大桶，就创建大桶\r\n    if (!depsMap) {\r\n        depsMap = new Map();\r\n        targetMap.set(target, depsMap);\r\n    }\r\n    //这行代码的含义是，如果当前target对象有桶（大桶），那么从所有字段的副作用函数集合（所有小桶）中，取出当前key的副作用函数集合（小桶）\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        // 创建当前字段装副作用函数的小桶\r\n        dep = new Set();\r\n        depsMap.set(key, dep);\r\n    }\r\n    trackEffects(dep);\r\n}\r\nexport function trackEffects(dep) {\r\n    // 判断当前的副作用函数是否已经被收集过，收集过就不用再收集了，虽然set可以过滤重复的，但还是有效率问题\r\n    let shouldTrack = !dep.has(activeEffect);\r\n    // 如果是内层的effect 我们可以将之前的先清空掉\r\n    // if (effectStack.length === 1) {\r\n    //   dep.clear()\r\n    // }\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep); // 副作用函数保存自己被哪些 target.key 所收集\r\n    }\r\n}\r\n/**\r\n * @param target {Target }\r\n * @param key   { string | number | symbol }\r\n * @param type  { TriggerOpTypes }  触发更新的操作，修改，删除，新增\r\n * @param newValue  { unknown }  用于修改 arr.length = xxx 的时候，此时的 key == 'length' 而 newValue 就是修改的长度的值\r\n * @returns\r\n */\r\nexport function trigger(target, key, type, newValue) {\r\n    // 设置新的值以后，取出当前target所对应的大桶\r\n    const depsMap = targetMap.get(target);\r\n    // 如果没有大桶直接返回,表明属性没有依赖任何的effect\r\n    if (!depsMap)\r\n        return;\r\n    let deps = []; // [set,set]\r\n    // 如果修改 arr.length，将索引大于等于 newValue(修改length的值) 的副作用函数取出来执行\r\n    if (key === 'length' && isArray(target)) {\r\n        const newLength = toNumber(newValue);\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newLength) {\r\n                deps.push(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // 执行 target key 的副作用函数\r\n        if (key !== void 0) { // 这里有个问题,就是当前trigger是由于增添属性触发的时候,这里 target key 会获取到undefined\r\n            deps.push(depsMap.get(key));\r\n        }\r\n        switch (type) {\r\n            // 只有当操作类型为 'ADD' 时，才触发 target 身上 key == ITERATE_KEY 相关联的副作用函数重新执行\r\n            case \"add\" /* TriggerOpTypes.ADD */:\r\n                // 这里会进行不同的判断,因为保存增添操作所对应的副作用函数的标识符会根据数据类型不同而变化\r\n                if (!isArray(target)) { // 如果增添属性的对象是普对对象,取出for in的副作用函数\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) { // // 如果增添属性的对象是Map对象,取出Map所对应的for in副作用函数\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                /**\r\n                 *  这里为什么还需要 isIntergerKey 去判断 key 是否为符合数组的索引类型?\r\n                 *    因为 TriggerOpTypes.ADD 只是确认了当前的属性为新增属性,当走到 else if (isIntegerKey(key)) 的时候\r\n                 *    只能说明 target 是数组类型,但是不能确保key是不是符合数组的索引属性,因此需要判断一下\r\n                 *  */\r\n                else if (isIntegerKey(key)) { // 如果为数组新增元素，应该触发与length相关的副作用函数\r\n                    deps.push(depsMap.get('length'));\r\n                }\r\n                break;\r\n            // 只有当操作类型为 'DELETE' 时，才触发 target 身上 key == ITERATE_KEY 相关联的副作用函数重新执行\r\n            case \"delete\" /* TriggerOpTypes.DELETE */:\r\n                if (!isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* TriggerOpTypes.SET */:\r\n                if (isMap(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const effects = [];\r\n    for (const dep of deps) { // dep -> set\r\n        // 防止当前trigger是由于增添属性触发的时候,上面 deps.push(depsMap.get(key)) 会添加 undefined 到deps里面\r\n        if (dep) {\r\n            effects.push(...dep);\r\n        }\r\n    }\r\n    triggerEffects(effects);\r\n}\r\nexport function triggerEffects(dep) {\r\n    // 老问题出现了，因为我们传入的dep是Dep，一个set集合，遍历的时候执行run，run中将当前的effect从dep中删除，但是重新执行又添加进去，导致死循环\r\n    const effects = isArray(dep) ? dep : [...dep];\r\n    for (const effect of effects) {\r\n        // 防止 effect 中同时执行和赋值导致死循环\r\n        if (effect !== activeEffect) {\r\n            if (effect.scheduler) {\r\n                return effect.scheduler();\r\n            }\r\n            effect.run();\r\n        }\r\n    }\r\n}\r\n// 副作用函数的构造函数\r\nexport function effect(fn, options) {\r\n    const _effect = new ReactiveEffect(fn); // 这里导致嵌套函数有问题\r\n    //合并\r\n    if (options) {\r\n        extend(_effect, options);\r\n    }\r\n    if (!options || !options.lazy) {\r\n        _effect.run(); // 默认让fn执行一次\r\n    }\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect; // 给runner添加一个effect属性就是_effect实例\r\n    // runner 可以强制重新执行effect\r\n    return runner;\r\n}\r\n//# sourceMappingURL=effect.js.map","references":["F:/forTest/v-rmake/packages/reactivity/src/operations.ts","F:/forTest/v-rmake/packages/reactivity/src/reactive.ts","F:/forTest/v-rmake/packages/reactivity/src/dep.ts","F:/forTest/v-rmake/packages/shared/src/index.ts"],"map":"{\"version\":3,\"file\":\"effect.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../packages/reactivity/src/effect.ts\"],\"names\":[],\"mappings\":\"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\"}"}
