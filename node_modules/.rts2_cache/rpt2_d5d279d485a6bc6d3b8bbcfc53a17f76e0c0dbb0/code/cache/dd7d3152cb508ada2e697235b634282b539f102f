{"code":"/**\r\n * effect1(()=>{\r\n *    state.name\r\n *    effect2(()=>{\r\n *      state.age\r\n *    })\r\n *    state.slary\r\n * })\r\n *\r\n * effect1 -> name slary\r\n * effect2 -> age\r\n *\r\n * 用栈来处理，存储正确的关系\r\n */\r\nlet effectStack = [];\r\nexport let activeEffect;\r\nfunction cleanupEffect(effect) {\r\n    // deps 是当前副作用函数身上的一个属性，这个属性中存储了那些object.key收集了当前effect所对应的set集合\r\n    const { deps } = effect; // deps -> [set,set]\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            // 重新执行副作用函数的时候，将当前副作用函数从这个 deps 当中删除\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nexport class ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = []; // 让 effect 记录他依赖了哪些属性，同时要记录当前属性依赖了哪个effect \r\n        this.parent = undefined;\r\n    }\r\n    run() {\r\n        // 如果不是激活状态\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        /**\r\n         * 防止死循环，比如\r\n         * effect(()=>{\r\n         *    state.name = Math.Romdom()\r\n         * })\r\n         */\r\n        if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行 \r\n            try {\r\n                // 激活状态的话，需要建立属性和依赖的关系\r\n                activeEffect = this;\r\n                effectStack.push(activeEffect);\r\n                return this.fn(); // 访问data的属性，触发getter （依赖收集）\r\n                // activeEffect = effectStack.pop()\r\n            }\r\n            finally {\r\n                effectStack.pop(); // 嵌套副作用函数执行完毕以后将最里层的副作用函数pop出去\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    }\r\n    // 清除依赖关系，可以手动调用stop执行\r\n    stop() {\r\n        if (this.active) // 如果effect是激活的采取将deps上的effect移除\r\n         {\r\n            cleanupEffect(this);\r\n            this.active = false; // 关闭当前effect的激活状态\r\n        }\r\n    }\r\n}\r\nconst targetMap = new WeakMap();\r\nexport function isTracking() {\r\n    return activeEffect !== undefined;\r\n}\r\n// 追踪 一个属性对应多个effect 多个属性对应一个effect\r\nexport function track(target, key) {\r\n    // 判断这个 state.name 访问属性的操作是不是在 effect 中执行的，简单来说就是判断需不需要收集\r\n    if (!isTracking()) { //如果这个属性不依赖于 effect 直接跳出\r\n        return;\r\n    }\r\n    // 根据 target 从 '桶' 当中取得depsMap ,他是一个 Map 类型: key -> effetcs\r\n    // 这行代码的含义就是从桶（大桶）当中拿出 target 对象所有字段的副作用函数集合（所有小桶）  \r\n    let depsMap = targetMap.get(target);\r\n    //如果当前target对象还没有它的大桶，就创建大桶\r\n    if (!depsMap) {\r\n        depsMap = new Map();\r\n        targetMap.set(target, depsMap);\r\n    }\r\n    //这行代码的含义是，如果当前target对象有桶（大桶），那么从所有字段的副作用函数集合（所有小桶）中，取出当前key的副作用函数集合（小桶）\r\n    let deps = depsMap.get(key);\r\n    if (!deps) {\r\n        // 创建当前字段装副作用函数的小桶\r\n        deps = new Set();\r\n        depsMap.set(key, deps);\r\n    }\r\n    // 判断当前的副作用函数是否已经被收集过，收集过就不用再收集了，虽然set可以过滤重复的，但还是有效率问题\r\n    let shouldTrack = deps.has(activeEffect);\r\n    if (!shouldTrack) {\r\n        deps.add(activeEffect);\r\n        activeEffect.deps.push(deps); // 副作用函数保存自己被哪些 target.key 所收集\r\n    }\r\n}\r\nexport function trigger(target, key) {\r\n    // 设置新的值以后，取出当前target所对应的大桶\r\n    const depsMap = targetMap.get(target);\r\n    // 如果没有大桶直接返回,表明属性没有依赖任何的effect\r\n    if (!depsMap)\r\n        return;\r\n    let deps = []; // [set,set]\r\n    if (key !== void 0) {\r\n        deps.push(depsMap.get(key));\r\n    }\r\n    const effects = [];\r\n    for (const dep of deps) { // dep -> set\r\n        effects.push(...dep);\r\n    }\r\n    for (const effect of effects) {\r\n        // 防止 effect 中同时执行和赋值导致死循环\r\n        if (effect !== activeEffect) {\r\n            effect.run();\r\n        }\r\n    }\r\n}\r\nexport function triggerEffects(dep) { }\r\nexport function effect(fn, options) {\r\n    const _effect = new ReactiveEffect(fn);\r\n    _effect.run(); // 默认让fn执行一次\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect; // 给runner添加一个effect属性就是_effect实例\r\n    // runner 可以强制重新执行effect\r\n    return runner;\r\n}\r\n//# sourceMappingURL=effect.js.map","references":["F:/forTest/monorope2/packages/reactivity/src/operations.ts","F:/forTest/monorope2/packages/reactivity/src/reactive.ts","F:/forTest/monorope2/packages/reactivity/src/dep.ts"],"map":"{\"version\":3,\"file\":\"effect.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../packages/reactivity/src/effect.ts\"],\"names\":[],\"mappings\":\"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\"}"}
