{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/warning.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/computed.ts","../src/ref.ts"],"sourcesContent":["// 判断传入的数据是否为对象类型\r\nexport const isObject = (val: unknown): val is Record<any, any> => val !== null && typeof val === 'object'\r\n\r\n\r\n// 判断是否是一个函数\r\nexport const isFunction = (val: unknown): val is Function => typeof val === 'function'\r\n\r\n\r\n// computed要用\r\nexport const NOOP = () => { }\r\n\r\n\r\n// 判断数组\r\nexport const isArray = Array.isArray\r\n\r\n\r\n// 判断Map\r\nexport const isMap = (val: unknown): val is Map<any, any> => toTypeString(val) === '[object Map]'\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string => objectToString.call(value)\r\n\r\n\r\nexport const extend = Object.assign\r\n\r\n\r\n// 判断当前访问的key是否是target自身的属性\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key) // 相当于obj.hasOwnProperty(key)\r\n\r\n\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\n// 判断是否是一个number类型的key\r\nexport const isIntegerKey = (key: unknown) => isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key\r\n\r\n\r\n// 判断值是否发生变化 Object.is 比 == 甚至 === 更严格，== 会类型转换，0 -0 ===会相等，而 Object.is 返回false\r\nexport const hasChanged = (value: any, oldValue: any): boolean => !Object.is(value, oldValue)","import { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { Target } from './reactive'\r\nimport { Dep } from './dep'\r\nimport { isArray, extend, isMap, isIntegerKey } from '@vue/shared'\r\n/**\r\n * effect1(()=>{\r\n *    state.name\r\n *    effect2(()=>{\r\n *      state.age\r\n *    })\r\n *    state.slary\r\n * })\r\n * \r\n * effect1 -> name slary\r\n * effect2 -> age\r\n * \r\n * 用栈来处理，存储正确的关系\r\n */\r\nlet effectStack: ReactiveEffect[] = []\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n\r\nexport const ITERATE_KEY = Symbol('iterate')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate')\r\n\r\nfunction cleanupEffect(effect: ReactiveEffect) {\r\n  // deps 是当前副作用函数身上的一个属性，这个属性中存储了那些object.key收集了当前effect所对应的set集合\r\n  const { deps } = effect // deps -> [set,set]\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      // 重新执行副作用函数的时候，将当前副作用函数从这个 deps 当中删除\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  deps: Dep[] = [] // 让 effect 记录他依赖了哪些属性，同时要记录当前属性依赖了哪个effect \r\n  parent: ReactiveEffect | undefined = undefined\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public scheduler: any | null = null,\r\n    scope?: any\r\n  ) {\r\n  }\r\n\r\n  run() {\r\n    // 如果不是激活状态\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n\r\n    /**\r\n     * 防止死循环，比如\r\n     * effect(()=>{\r\n     *    state.name = Math.Romdom()\r\n     * })\r\n     */\r\n\r\n    if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行 \r\n      try {\r\n        // 激活状态的话，需要建立属性和依赖的关系\r\n        cleanupEffect(this) // 清空分支切换时遗留的副作用函数\r\n        activeEffect = this;\r\n        effectStack.push(activeEffect)\r\n        return this.fn(); // 访问data的属性，触发getter （依赖收集）\r\n      } finally {\r\n        effectStack.pop() // 嵌套副作用函数执行完毕以后将最里层的副作用函数pop出去\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n      }\r\n    }\r\n  }\r\n\r\n  // 清除依赖关系，可以手动调用stop执行\r\n  stop() {\r\n    if (this.active) // 如果effect是激活的采取将deps上的effect移除\r\n    {\r\n      cleanupEffect(this)\r\n      this.active = false // 关闭当前effect的激活状态\r\n    }\r\n  }\r\n}\r\n\r\nexport const targetMap = new WeakMap();\r\n\r\nexport function isTracking() {\r\n  return activeEffect !== undefined\r\n}\r\n\r\n// 追踪 一个属性对应多个effect 多个属性对应一个effect\r\nexport function track(target: object, key: unknown, type?: TrackOpTypes) {\r\n  // 判断这个 state.name 访问属性的操作是不是在 effect 中执行的，简单来说就是判断需不需要收集\r\n  if (!isTracking()) { //如果这个属性不依赖于 effect 直接跳出\r\n    return\r\n  }\r\n  // 根据 target 从 '桶' 当中取得depsMap ,他是一个 Map 类型: key -> effetcs\r\n  // 这行代码的含义就是从桶（大桶）当中拿出 target 对象所有字段的副作用函数集合（所有小桶）  \r\n  let depsMap = targetMap.get(target)\r\n\r\n  //如果当前target对象还没有它的大桶，就创建大桶\r\n  if (!depsMap) {\r\n    depsMap = new Map()\r\n    targetMap.set(target, depsMap)\r\n  }\r\n\r\n  //这行代码的含义是，如果当前target对象有桶（大桶），那么从所有字段的副作用函数集合（所有小桶）中，取出当前key的副作用函数集合（小桶）\r\n  let dep = depsMap.get(key)\r\n\r\n  if (!dep) {\r\n    // 创建当前字段装副作用函数的小桶\r\n    dep = new Set()\r\n    depsMap.set(key, dep)\r\n  }\r\n\r\n  // 判断当前的副作用函数是否已经被收集过，收集过就不用再收集了，虽然set可以过滤重复的，但还是有效率问题\r\n  trackEffects(dep)\r\n}\r\n\r\nexport function trackEffects(dep: Dep) {\r\n  // 判断当前的副作用函数是否已经被收集过，收集过就不用再收集了，虽然set可以过滤重复的，但还是有效率问题\r\n  let shouldTrack = !dep.has(activeEffect)\r\n\r\n  // 如果是内层的effect 我们可以将之前的先清空掉\r\n  // if (effectStack.length === 1) {\r\n  //   dep.clear()\r\n  // }\r\n\r\n  if (shouldTrack) {\r\n    dep.add(activeEffect)\r\n    activeEffect.deps.push(dep) // 副作用函数保存自己被哪些 target.key 所收集\r\n  }\r\n}\r\n\r\nexport function trigger(target: Target, key: string | number | symbol, type?: TriggerOpTypes) {\r\n  // 设置新的值以后，取出当前target所对应的大桶\r\n  const depsMap = targetMap.get(target)\r\n\r\n  // 如果没有大桶直接返回,表明属性没有依赖任何的effect\r\n  if (!depsMap)\r\n    return;\r\n\r\n  let deps: (Dep | undefined)[] = [] // [set,set]\r\n  // 执行 target key 的副作用函数\r\n  if (key !== void 0) { // 这里有个问题,就是当前trigger是由于增添属性触发的时候,这里 target key 会获取到undefined\r\n    deps.push(depsMap.get(key))\r\n  }\r\n\r\n  switch (type) {\r\n    // 只有当操作类型为 'ADD' 时，才触发 target 身上 key == ITERATE_KEY 相关联的副作用函数重新执行\r\n    case TriggerOpTypes.ADD:\r\n      // 这里会进行不同的判断,因为保存增添操作所对应的副作用函数的标识符会根据数据类型不同而变化\r\n      if (!isArray(target)) { // 如果增添属性的对象是普对对象,取出for in的副作用函数\r\n        deps.push(depsMap.get(ITERATE_KEY))\r\n        if (isMap(target)) { // // 如果增添属性的对象是Map对象,取出Map所对应的for in副作用函数\r\n          deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n        }\r\n      } \r\n      /**\r\n       *  这里为什么还需要 isIntergerKey 去判断 key 是否为符合数组的索引类型?\r\n       *    因为 TriggerOpTypes.ADD 只是确认了当前的属性为新增属性,当走到 else if (isIntegerKey(key)) 的时候\r\n       *    只能说明 target 是数组类型,但是不能确保key是不是符合数组的索引属性,因此需要判断一下\r\n       *  */\r\n      else if (isIntegerKey(key)) { \r\n        deps.push(depsMap.get('length'))\r\n      }\r\n      break\r\n    // 只有当操作类型为 'DELETE' 时，才触发 target 身上 key == ITERATE_KEY 相关联的副作用函数重新执行\r\n    case TriggerOpTypes.DELETE:\r\n      if (!isArray(target)) {\r\n        deps.push(depsMap.get(ITERATE_KEY))\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n        }\r\n      }\r\n      break\r\n    case TriggerOpTypes.SET:\r\n      if (isMap(target)) {\r\n        deps.push(depsMap.get(ITERATE_KEY))\r\n      }\r\n      break\r\n  }\r\n  \r\n  const effects: ReactiveEffect[] = []\r\n  for (const dep of deps) { // dep -> set\r\n    // 防止当前trigger是由于增添属性触发的时候,上面 deps.push(depsMap.get(key)) 会添加 undefined 到deps里面\r\n    if(dep){ \r\n      effects.push(...dep)\r\n    }\r\n  }\r\n\r\n  triggerEffects(effects)\r\n}\r\n\r\nexport function triggerEffects(dep: Dep | ReactiveEffect[]) {\r\n  // 老问题出现了，因为我们传入的dep是Dep，一个set集合，遍历的时候执行run，run中将当前的effect从dep中删除，但是重新执行又添加进去，导致死循环\r\n  const effects = isArray(dep) ? dep : [...dep]\r\n  for (const effect of effects) {\r\n    // 防止 effect 中同时执行和赋值导致死循环\r\n    if (effect !== activeEffect) {\r\n      if (effect.scheduler) {\r\n        return effect.scheduler()\r\n      }\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\n\r\nexport function effect<T = any>(fn: () => T, options?: any) {\r\n\r\n  const _effect = new ReactiveEffect(fn) // 这里导致嵌套函数有问题\r\n\r\n  //合并\r\n  if (options) {\r\n    extend(_effect, options)\r\n  }\r\n\r\n  if (!options || !options.lazy) {\r\n    _effect.run() // 默认让fn执行一次\r\n  }\r\n\r\n  const runner = _effect.run.bind(_effect)\r\n  runner.effect = _effect // 给runner添加一个effect属性就是_effect实例\r\n  // runner 可以强制重新执行effect\r\n  return runner\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}","export function warn(msg: string, ...args: any[]) {\r\n  console.warn(`[Vue warn] ${msg}`, ...args)\r\n}\r\n","import { reactive, ReactiveFlags, readonly, Target, toRaw } from './reactive'\r\nimport { ITERATE_KEY, track, trigger } from './effect'\r\nimport { extend, hasChanged, hasOwn, isArray, isIntegerKey, isObject } from '@vue/shared'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { warn } from './warning'\r\n\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target: Target, key: string | symbol, receiver: object) { // 代理对象的本身\r\n    // 如果target已经被代理过了就直接返回true\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return true\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      // 用于获取 receiver 的原始对象\r\n      return target\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    // 如果不是只读，触发getter收集副作用函数effect\r\n    if (!isReadonly) {\r\n      track(target, key)\r\n    }\r\n\r\n    // 如果是浅层次的读\r\n    if (shallow) {\r\n      return res\r\n    }\r\n\r\n    // 如果返回的对象是对象，判断是否为 readonly ,如果是 readonly 那么递归调用readonly，保证深层次的对象也是只读的，reactive 同理，递归包裹深层次对象成为响应式，可以深层次的实现响应式\r\n    if (isObject(res)) {\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nfunction createSetter(shallow = false) {\r\n  return function set(target: object, key: string | symbol, value: unknown, receiver: object) { // receiver是代理对象的本身\r\n    // 拿到旧值,便于触发更新前的比较\r\n    let oldValue = (target as any)[key]\r\n    /**\r\n     *  # hadKey 这一步用来判断当前访问的key,是否是target自身的属性，如果是的话表示当前的set操作是修改数据，反之则是增添属性的操作\r\n     * \r\n     *  # hadKey 这一步其实有2个作用\r\n     *    1.针对数组，判断原始数组是否有这个key\r\n     *        如果当前的原始对象是数组类型，并且key是数字类型，或者字符串的数字类型( 0 or '0')，执行 Number(key) < target.length 判单数组有没有这个key\r\n     *    2.针对对象，判断原始对象是否有这个key\r\n     *        如果当前的原始对象是对象类型，执行 hasOwn(target, key) ，判断自身是否含有key（不包括原型链上的属性）\r\n     */\r\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key)\r\n\r\n    // 需要先设置值，再去追踪，重新执行副作用函数，否者执行副作用函数的时候值没有发生变化\r\n    const res = Reflect.set(target, key, value, receiver)\r\n\r\n    // 这里判断当前代理对象的原始对象是否为target,防止原型链响应式对象触发 setter 导致重复触发 trigger\r\n    if (target === toRaw(receiver)) {\r\n      // 如果没有访问的key，无论是对于数组还是对象，都是新增属性\r\n      if (!hadKey) {\r\n        trigger(target, key, TriggerOpTypes.ADD)\r\n      } else if (hasChanged(value, oldValue)) { // 如果我们修改的属性值和原来的值一样，没必要去更新，影响性能\r\n        trigger(target, key, TriggerOpTypes.SET)\r\n      }\r\n    }\r\n    return res\r\n  }\r\n}\r\n\r\n// 'foo' in p \r\nfunction has(target: object, key: string | symbol): boolean {\r\n  const result = Reflect.has(target, key)\r\n  track(target, key)\r\n  return result\r\n}\r\n\r\n// for key in p \r\nfunction ownKeys(target: object): (string | symbol)[] {\r\n  // 判断当前遍历的对象是object类型还是数组类型\r\n  const key = isArray(target) ? 'length' : ITERATE_KEY\r\n  track(target, key, TrackOpTypes.ITERATE)\r\n  return Reflect.ownKeys(target)\r\n}\r\n\r\n// 删除属性的时候触发\r\nfunction deleteProperty(target: object, key: string | symbol): boolean {\r\n  // 判断要删除的属性是否存在当前的target身上\r\n  const hadKey = hasOwn(target, key)\r\n\r\n  const result = Reflect.deleteProperty(target, key)\r\n  // 当前 target 存在要删除的属性,并且成功删除了\r\n  if (result && hadKey) {\r\n    trigger(target, key, TriggerOpTypes.DELETE)\r\n  }\r\n  return result\r\n}\r\n\r\n// 深层次响应式模块的Handlers\r\nconst get = createGetter()\r\nconst set = createSetter()\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set,\r\n  has,\r\n  ownKeys,\r\n  deleteProperty\r\n}\r\n\r\n// 浅层次响应式模块的Handlers\r\nconst shallowGet = createGetter(false, true)\r\nconst shallowSet = createSetter(true)\r\n\r\nexport const shallowReactiveHandlers = extend(\r\n  {},\r\n  mutableHandlers,\r\n  // 用 shallowReactiveHandlers 覆盖 mutableHandlers 当中的 get 和 set ，其余继承\r\n  {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n  }\r\n)\r\n\r\n// 只读模块的Handlers\r\nconst readonlyGet = createGetter(true)\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> = {\r\n  get: readonlyGet, // 虽然是只读的，但是也是用reactive层层包裹了的，但是没有track去收集依赖\r\n  set(target, key) {\r\n    warn(\r\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n      target\r\n    )\r\n    return true\r\n  },\r\n  deleteProperty(target, key) {\r\n    warn(\r\n      `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n      target\r\n    )\r\n    return true\r\n  }\r\n}\r\n\r\n\r\n","import { isObject } from '@vue/shared'\r\n\r\nimport { mutableHandlers, readonlyHandlers, shallowReactiveHandlers } from './baseHandlers'\r\n\r\n\r\nconst reactiveMap = new WeakMap<Target, any>(); // 缓存代理过的target\r\n\r\n// 工厂函数\r\nexport function createReactiveObject(target: Target, isReadonly: boolean, baseHandlers: ProxyHandler<any>,) {\r\n\r\n  // 判断传入的数据是否为对象\r\n  if (!isObject(target)) {\r\n    // __DEV__用于判断当前的代码编写环境为开发环境的时候，发出警告，因此在生产环境下这段代码为dead code，利用tree-shaking(依赖于ES Module)移除掉\r\n    if ('__DEV__') {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n\r\n  // 判断target是否被代理过，如果target是一个响应式对象，这里会触发getter(主要针对于target是一个响应式对象，如果target是原始对象不会触发getter，只有响应式对象才会触发getter)\r\n  if (target[ReactiveFlags.IS_REACTIVE]) {\r\n    return target\r\n  }\r\n\r\n  // 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象，简单的说就是代理过的对象不再重复代理，取出之前创建的代理对象返回\r\n  const existionProxy = reactiveMap.get(target)\r\n  if (existionProxy)\r\n    return existionProxy\r\n\r\n  const proxy = new Proxy(target, baseHandlers) // 数据劫持\r\n\r\n  reactiveMap.set(target, proxy) // 缓存\r\n  return proxy // 返回代理\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\nexport function shallowReactive<T extends object>(target: T): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n  )\r\n}\r\n\r\nexport function reactive(target: object) {\r\n  return createReactiveObject(target, false, mutableHandlers)\r\n}\r\n\r\nexport function readonly<T extends object>(target: T) {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n  )\r\n}\r\n\r\n\r\nexport function shallowReadOnly(target: object) {\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive', // 一个对象已经被代理过的标志\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n\r\nexport function toRaw<T>(observed: T): T {\r\n  // 如果传入的对象是一个响应式对象,例如reactive代理的响应式对象,可以访问该代理对象的'__v_raw'属性,这个属性会返回代理对象的原始对象\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  // 如果这里获取到了原始对象,但是这个原始对象还可能是一个响应式对象,因此需要递归的去调用toRaw方法去获取原始对象,直到真正的获取到了原始对象\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  // 判断传入的原始数据是否为对象类型\r\n  // 如果传入的原始数据是对象类型,那么调用reactive去进行代理,这里reactive内部其实也是进行了相关的优化,如果一个原始值已经是被代理过的,那么会直接返回已经代理的对象,就不用重新去代理了\r\n  // 如果传入的原始数据不是对象类型,那么直接返回该数据\r\n  isObject(value) ? reactive(value as object) : value","import { isFunction, NOOP } from \"@vue/shared\"\r\nimport { Dep } from './dep'\r\nimport { isTracking, ReactiveEffect, trackEffects, triggerEffects } from './effect'\r\nimport { ReactiveFlags, toRaw } from \"./reactive\"\r\n\r\n/**\r\n * state.age 收集computed的副作用函数\r\n * \r\n * Myage.value 相当于计算属性收集最外层 effect\r\n * \r\n */\r\n// const Myage = computed(() => {\r\n//   return state.age + 19;\r\n// });\r\n// effect(() => {\r\n//   console.log(Myage.value); // 这样做的话相当于是个嵌套的effect,state.age收集了传给computed的副作用函数\r\n// });\r\n// // 需要通过.value 才执行\r\n// setTimeout(() => {\r\n//   state.age = 20;\r\n// }, 2000);\r\n\r\nexport type ComputedGetter<T> = (...args: any[]) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T> // 计算属性依赖于effect\r\n  public readonly __v_isRef = true\r\n  public _dirty = true  // 默认脏的\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly?: boolean,\r\n  ) {\r\n    // 这里将计算属性包成一个effect , getter相当于effect当中的副作用函数\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      // 稍后计算属性的值发生变化了,不要重新执行getter,而是走第二个函数\r\n      if (!this._dirty) {\r\n        this._dirty = true\r\n        // 重新执行最外层的effect\r\n        triggerEffects(this.dep)\r\n      }\r\n    })\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  // 取值时, 编译完就是Object.defineProperty\r\n  get value() {\r\n    if (isTracking()) { //是否是在effect中取值的\r\n      trackEffects(this.dep || (this.dep = new Set<ReactiveEffect>)) // 将外层的effect收集,相当于收集 computed.value -> Set(effect)\r\n    }\r\n\r\n    if (this._dirty) {\r\n      // 缓存结果 \r\n      this._dirty = false\r\n      this._value = this.effect.run()\r\n    }\r\n    return this._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue) // 如果修改计算属性的值就走setter\r\n  }\r\n}\r\n\r\nexport function computed<T>(getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>) {\r\n  // 判断传入的值是函数还是配置对象{get,set}\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = false // __DEV__\r\n      ? () => {\r\n        console.warn('Write operation failed: computed value is readonly')\r\n      }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  return new ComputedRefImpl(getter, setter)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import { Dep } from './dep'\r\nimport { isObject } from '@vue/shared'\r\nimport { reactive, toRaw, toReactive } from './reactive'\r\nimport { isTracking, trackEffects } from './effect'\r\n\r\n// ref入口函数\r\nexport function ref(value?: unknown) {\r\n  // 内部调用 createRef 函数，尾调用优化\r\n  return createRef(value, false)\r\n}\r\n\r\n// 真正创建 ref 实例的构造韩素华\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  // 判断传入的值是否为ref的实例，如果是直接返回\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n\r\n  // 如果不是，调用RefImpl构造函数，即创建ref实例 ， value,false\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\n// ref\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n\r\n  // 判断当前的实例是否为Ref对象\r\n  public readonly __v_isRef = true\r\n\r\n  // 这里ref 的 __v_isShallow 为false，用于判断是不是浅层次的响应式,即判断调用的函数时shallowRef 还是 ref\r\n  constructor(value: T, public readonly __v_isShallow: boolean) {\r\n\r\n    // 这里传入的值可能是一个reactive代理的响应式对象，因此通过toRaw方法，返回reactive代理的原始对象\r\n    this._rawValue = __v_isShallow ? value : toRaw(value) // 访问value['__v_raw]获取到原始对象并进行保存\r\n\r\n    // 对原始数据进行代理\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n\r\n    /**\r\n     *  执行到这里的时候,ref的实例已经是创建完成\r\n     *    让我们回顾整个创建的过程\r\n     *      1.首先我们是获取了传入的数据的原始数据\r\n     *      2.判断原始数据的数据类型是否为对象类型,如果是对象调用 reactive 进行代理,反之返回原始数据\r\n     *      3.将最终处理的数据保存在 _value 当中,基本数据类型就是基本数据类型,引用类型就通过 reactive 代理\r\n     */\r\n  }\r\n\r\n  /**\r\n   * 通过ref实例.value 获取到 _value 的值，_value值的类型根据 toReactive()的返回结果决定，\r\n   * 如果不是对象就是原始值。如果是对象，返回的是通过 reactive() 包装后的对象，也就是通过 Proxy() 代理的\r\n   */\r\n  get value() {\r\n    // 取值的时候依赖收集\r\n    if (isTracking()) {\r\n      trackEffects(this.dep || (this.dep = new Set()))\r\n    }\r\n    return this._value\r\n  }\r\n\r\n  // 在这里，无论是ref还是shallowRef的实例对象，都是同样的方式进行存储\r\n  set value(newVal) {\r\n    // 设置值的时候触发更新\r\n    if (newVal !== this._rawValue) {\r\n      this._rawValue = newVal\r\n      this._value = toReactive(newVal)\r\n      trackEffects(this.dep)\r\n    }\r\n  }\r\n}\r\n\r\nexport function shallowRef<T extends object>(\r\n  value: T\r\n): T extends Ref ? T : ShallowRef<T>\r\nexport function shallowRef<T>(value: T): ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  [RefSymbol]: true\r\n}\r\n\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\n\r\n// 如果传入ref的对象，已经是 ref 的实例\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}