{"version":3,"file":"reactivity.global.js","sources":["../src/effect.ts","../../shared/src/index.ts","../src/reactive.ts"],"sourcesContent":["import { TrackOpTypes } from './operations'\r\n\r\n/**\r\n * effect1(()=>{\r\n *    state.name\r\n *    effect2(()=>{\r\n *      state.age\r\n *    })\r\n *    state.slary\r\n * })\r\n * \r\n * effect1 -> name slary\r\n * effect2 -> age\r\n * \r\n * 用栈来处理，存储正确的关系\r\n */\r\nlet effectStack = []\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  deps: Dep[] = [] // 让 effect 记录他依赖了哪些属性，同时要记录当前属性依赖了哪个effect \r\n  parent: ReactiveEffect | undefined = undefined\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public scheduler: any | null = null,\r\n    scope?: any\r\n  ) {\r\n  }\r\n\r\n  run() {\r\n    // 如果不是激活状态\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n\r\n    /**\r\n     * \r\n     * 防止死循环，比如\r\n     * effect(()=>{\r\n     *    state.name = Math.Romdom()\r\n     * })\r\n     * \r\n     * \r\n     */\r\n\r\n    if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行 \r\n      try {\r\n        // 激活状态的话，需要建立属性和依赖的关系\r\n        activeEffect = this;\r\n        effectStack.push(activeEffect)\r\n        return this.fn(); // 访问data的属性，触发getter （依赖收集）\r\n        // activeEffect = effectStack.pop()\r\n      } finally {\r\n        effectStack.pop() // 嵌套副作用函数执行完毕以后将最里层的副作用函数pop出去\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  stop() {\r\n\r\n  }\r\n}\r\n\r\n\r\nconst targetMap = new WeakMap();\r\n\r\n\r\nexport function isTracking() {\r\n  return activeEffect !== undefined\r\n}\r\n\r\n// 追踪 一个属性对应多个effect 多个属性对应一个effect\r\nexport function track(target: object, key: unknown) {\r\n\r\n  // 判断这个 state.name 访问属性的操作是不是在 effect 中执行的，简单来说就是判断需不需要收集\r\n  if (!isTracking()) { //如果这个属性不依赖于 effect 直接跳出\r\n    return\r\n  }\r\n\r\n  // 根据 target 从 '桶' 当中取得depsMap ,他是一个 Map 类型: key -> effetcs\r\n  // 这行代码的含义就是从桶（大桶）当中拿出 target 对象所有字段的副作用函数集合（所有小桶）  \r\n  let depsMap = targetMap.get(target)\r\n\r\n  //如果当前target对象还没有它的大桶，就创建大桶\r\n  if (!depsMap) {\r\n    depsMap = new Map()\r\n    targetMap.set(target, depsMap)\r\n  }\r\n\r\n\r\n  //这行代码的含义是，如果当前target对象有桶（大桶），那么从所有字段的副作用函数集合（所有小桶）中，取出当前key的副作用函数集合（小桶）\r\n  let deps = depsMap.get(key)\r\n\r\n  if (!deps) {\r\n    // 创建当前字段装副作用函数的小桶\r\n    deps = new Set()\r\n    depsMap.set(key, deps)\r\n  }\r\n\r\n  // 为当前字段(小桶)添加副作用函数,这个副作用函数当前是激活的\r\n  // 无论是首次调用effect()函数，还是trigger触发更新，都会走这一步，由于trigger触发更新的时候，activeEffect引用的对象是相同的，Set会自动过滤重复的\r\n  // 有了cleanup函数之后，每次触发前都进行了依赖删除，那么就不会触发Set的自动过滤了\r\n  let shouldTrack = deps.has(activeEffect)\r\n  if (shouldTrack) {\r\n    deps.add(activeEffect)\r\n  }\r\n\r\n\r\n}\r\n\r\nexport function effect<T = any>(fn: () => T, options?) {\r\n\r\n  const _effect = new ReactiveEffect(fn)\r\n\r\n  _effect.run() // 默认让fn执行一次\r\n}\r\n\r\n\r\n\r\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\r\n\r\ntype TrackedMarkers = {\r\n  w: number\r\n  n: number\r\n}","\r\n\r\n// 判断传入的数据是否为对象类型\r\nexport const isObject = (val: unknown): val is Record<any, any> => val !== null && typeof val === 'object'\r\n","import { isObject } from '@vue/shared'\r\nimport { track } from './effect'\r\n\r\n\r\n\r\nconst mutableHandlers: ProxyHandler<Record<any, any>> = {\r\n  get(target, key, recevier) { // 代理对象的本身\r\n    // 如果target已经被代理过了就直接返回true\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return true\r\n    }\r\n    // 触发getter收集副作用函数effect\r\n    track(target, key)\r\n\r\n\r\n\r\n    return Reflect.get(target, key, recevier)\r\n\r\n  },\r\n  set(target, key, value, recevier) {\r\n    return Reflect.set(target, key, value, recevier)\r\n  }\r\n}\r\n\r\nconst reactiveMap = new WeakMap<Target, any>(); // 缓存代理过的target\r\n\r\n// 工厂函数\r\nexport function createReactiveObject(target: Target) {\r\n\r\n  // 判断传入的数据是否为对象\r\n  if (!isObject(target)) {\r\n    // __DEV__用于判断当前的代码编写环境为开发环境的时候，发出警告，因此在生产环境下这段代码为dead code，利用tree-shaking(依赖于ES Module)移除掉\r\n    if ('__DEV__') {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n\r\n  // 判断target是否被代理过，如果target是一个响应式对象，这里会触发getter(主要针对于target是一个响应式对象，如果target是原始对象不会触发getter，只有响应式对象才会触发getter)\r\n  if (target[ReactiveFlags.IS_REACTIVE]) {\r\n    return target\r\n  }\r\n\r\n  // 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象，简单的说就是代理过的对象不再重复代理，取出之前创建的代理对象返回\r\n  const existionProxy = reactiveMap.get(target)\r\n  if (existionProxy)\r\n    return existionProxy\r\n\r\n  const proxy = new Proxy(target, mutableHandlers) // 数据劫持\r\n\r\n  reactiveMap.set(target, proxy) // 缓存\r\n\r\n\r\n  return proxy // 返回代理\r\n}\r\n\r\n\r\n\r\nexport function reactive(target: object) {\r\n  return createReactiveObject(target)\r\n}\r\n\r\nexport function readonly(target: object) {\r\n\r\n}\r\n\r\n\r\nexport function shallowReactive(target: object) {\r\n\r\n}\r\n\r\nexport function shallowReadOnly(target: object) {\r\n\r\n}\r\n\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive', // 一个对象已经被代理过的标志\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n"],"names":[],"mappings":"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"}