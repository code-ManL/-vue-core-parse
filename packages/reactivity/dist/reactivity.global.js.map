{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/computed.ts","../src/ref.ts"],"sourcesContent":["\r\n\r\n// 判断传入的数据是否为对象类型\r\nexport const isObject = (val: unknown): val is Record<any, any> => val !== null && typeof val === 'object'\r\n\r\n// 判断是否是一个函数\r\nexport const isFunction = (val: unknown): val is Function => typeof val === 'function'\r\n\r\n// computed要用\r\nexport const NOOP = () => {}\r\n\r\n\r\nexport const isArray = Array.isArray","import { TrackOpTypes } from './operations'\r\nimport { Target } from './reactive'\r\nimport { Dep } from './dep'\r\nimport { isArray } from '@vue/shared'\r\n/**\r\n * effect1(()=>{\r\n *    state.name\r\n *    effect2(()=>{\r\n *      state.age\r\n *    })\r\n *    state.slary\r\n * })\r\n * \r\n * effect1 -> name slary\r\n * effect2 -> age\r\n * \r\n * 用栈来处理，存储正确的关系\r\n */\r\nlet effectStack: ReactiveEffect[] = []\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\n\r\nfunction cleanupEffect(effect: ReactiveEffect) {\r\n  // deps 是当前副作用函数身上的一个属性，这个属性中存储了那些object.key收集了当前effect所对应的set集合\r\n  const { deps } = effect // deps -> [set,set]\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      // 重新执行副作用函数的时候，将当前副作用函数从这个 deps 当中删除\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  deps: Dep[] = [] // 让 effect 记录他依赖了哪些属性，同时要记录当前属性依赖了哪个effect \r\n  parent: ReactiveEffect | undefined = undefined\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public scheduler: any | null = null,\r\n    scope?: any\r\n  ) {\r\n  }\r\n\r\n  run() {\r\n    // 如果不是激活状态\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n\r\n    /**\r\n     * 防止死循环，比如\r\n     * effect(()=>{\r\n     *    state.name = Math.Romdom()\r\n     * })\r\n     */\r\n\r\n    if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行 \r\n      try {\r\n        // 激活状态的话，需要建立属性和依赖的关系\r\n        cleanupEffect(this) // 清空分支d切换时遗留的副作用函数\r\n        activeEffect = this;\r\n        effectStack.push(activeEffect)\r\n        return this.fn(); // 访问data的属性，触发getter （依赖收集）\r\n      } finally {\r\n        effectStack.pop() // 嵌套副作用函数执行完毕以后将最里层的副作用函数pop出去\r\n        activeEffect = effectStack[effectStack.length - 1]\r\n      }\r\n    }\r\n  }\r\n\r\n  // 清除依赖关系，可以手动调用stop执行\r\n  stop() {\r\n    if (this.active) // 如果effect是激活的采取将deps上的effect移除\r\n    {\r\n      cleanupEffect(this)\r\n      this.active = false // 关闭当前effect的激活状态\r\n    }\r\n  }\r\n}\r\n\r\nexport const targetMap = new WeakMap();\r\n\r\nexport function isTracking() {\r\n  return activeEffect !== undefined\r\n}\r\n\r\n// 追踪 一个属性对应多个effect 多个属性对应一个effect\r\nexport function track(target: object, key: unknown) {\r\n  // 判断这个 state.name 访问属性的操作是不是在 effect 中执行的，简单来说就是判断需不需要收集\r\n  if (!isTracking()) { //如果这个属性不依赖于 effect 直接跳出\r\n    return\r\n  }\r\n  // 根据 target 从 '桶' 当中取得depsMap ,他是一个 Map 类型: key -> effetcs\r\n  // 这行代码的含义就是从桶（大桶）当中拿出 target 对象所有字段的副作用函数集合（所有小桶）  \r\n  let depsMap = targetMap.get(target)\r\n\r\n  //如果当前target对象还没有它的大桶，就创建大桶\r\n  if (!depsMap) {\r\n    depsMap = new Map()\r\n    targetMap.set(target, depsMap)\r\n  }\r\n\r\n  //这行代码的含义是，如果当前target对象有桶（大桶），那么从所有字段的副作用函数集合（所有小桶）中，取出当前key的副作用函数集合（小桶）\r\n  let dep = depsMap.get(key)\r\n\r\n  if (!dep) {\r\n    // 创建当前字段装副作用函数的小桶\r\n    dep = new Set()\r\n    depsMap.set(key, dep)\r\n  }\r\n\r\n  // 判断当前的副作用函数是否已经被收集过，收集过就不用再收集了，虽然set可以过滤重复的，但还是有效率问题\r\n  trackEffects(dep)\r\n}\r\n\r\nexport function trackEffects(dep: Dep) {\r\n  // 判断当前的副作用函数是否已经被收集过，收集过就不用再收集了，虽然set可以过滤重复的，但还是有效率问题\r\n  let shouldTrack = !dep.has(activeEffect)\r\n  if (shouldTrack) {\r\n    dep.add(activeEffect)\r\n    activeEffect.deps.push(dep) // 副作用函数保存自己被哪些 target.key 所收集\r\n  }\r\n}\r\n\r\nexport function trigger(target: Target, key: string | number | symbol) {\r\n  // 设置新的值以后，取出当前target所对应的大桶\r\n  const depsMap = targetMap.get(target)\r\n\r\n  // 如果没有大桶直接返回,表明属性没有依赖任何的effect\r\n  if (!depsMap)\r\n    return;\r\n\r\n  let deps: (Dep | undefined)[] = [] // [set,set]\r\n  if (key !== void 0) {\r\n    deps.push(depsMap.get(key))\r\n  }\r\n\r\n  const effects: ReactiveEffect[] = []\r\n  for (const dep of deps) { // dep -> set\r\n    effects.push(...dep)\r\n  }\r\n\r\n  triggerEffects(effects)\r\n}\r\n\r\nexport function triggerEffects(dep: Dep | ReactiveEffect[]) {\r\n  // 老问题出现了，因为我们传入的dep是Dep，一个set集合，遍历的时候执行run，run中将当前的effect从dep中删除，但是重新执行又添加进去，导致死循环\r\n  const effects = isArray(dep) ? dep : [...dep]\r\n  for (const effect of effects) {\r\n    // 防止 effect 中同时执行和赋值导致死循环\r\n    if (effect !== activeEffect) {\r\n      if (effect.scheduler) {\r\n        return effect.scheduler()\r\n      }\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\n\r\nexport function effect<T = any>(fn: () => T, options?) {\r\n\r\n  const _effect = new ReactiveEffect(fn) // 这里导致嵌套函数有问题\r\n\r\n  _effect.run() // 默认让fn执行一次\r\n\r\n  const runner = _effect.run.bind(_effect)\r\n  runner.effect = _effect // 给runner添加一个effect属性就是_effect实例\r\n  // runner 可以强制重新执行effect\r\n  return runner\r\n}\r\n\r\n\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}","import { ReactiveFlags, Target } from './reactive'\r\nimport { track, trigger } from './effect'\r\n\r\n\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target: Target, key: string | symbol, receiver: object) { // 代理对象的本身\r\n    // 如果target已经被代理过了就直接返回true\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return true\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n    // 触发getter收集副作用函数effect\r\n    track(target, key)\r\n    return Reflect.get(target, key, receiver)\r\n  }\r\n}\r\n\r\nfunction createSetter(shallow = false) {\r\n  return function set(target: object, key: string | symbol, value: unknown, receiver: object) { // 代理对象的本身\r\n    // 需要先设置值，再去追踪，重新执行副作用函数\r\n    const res = Reflect.set(target, key, value, receiver)\r\n    trigger(target, key)\r\n    return res\r\n  }\r\n}\r\n\r\nconst get = createGetter()\r\nconst set = createSetter()\r\n\r\nexport const mutableHandlers: ProxyHandler<object> = {\r\n  get,\r\n  set\r\n}\r\n\r\n\r\n\r\n","import { isObject } from '@vue/shared'\r\n\r\nimport { mutableHandlers } from './baseHandlers'\r\n\r\n\r\nconst reactiveMap = new WeakMap<Target, any>(); // 缓存代理过的target\r\n\r\n// 工厂函数\r\nexport function createReactiveObject(target: Target) {\r\n\r\n  // 判断传入的数据是否为对象\r\n  if (!isObject(target)) {\r\n    // __DEV__用于判断当前的代码编写环境为开发环境的时候，发出警告，因此在生产环境下这段代码为dead code，利用tree-shaking(依赖于ES Module)移除掉\r\n    if ('__DEV__') {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n\r\n  // 判断target是否被代理过，如果target是一个响应式对象，这里会触发getter(主要针对于target是一个响应式对象，如果target是原始对象不会触发getter，只有响应式对象才会触发getter)\r\n  if (target[ReactiveFlags.IS_REACTIVE]) {\r\n    return target\r\n  }\r\n\r\n  // 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象，简单的说就是代理过的对象不再重复代理，取出之前创建的代理对象返回\r\n  const existionProxy = reactiveMap.get(target)\r\n  if (existionProxy)\r\n    return existionProxy\r\n\r\n  const proxy = new Proxy(target, mutableHandlers) // 数据劫持\r\n\r\n  reactiveMap.set(target, proxy) // 缓存\r\n  return proxy // 返回代理\r\n}\r\n\r\nexport function reactive(target: object) {\r\n  return createReactiveObject(target)\r\n}\r\n\r\nexport function readonly(target: object) {\r\n\r\n}\r\n\r\nexport function shallowReactive(target: object) {\r\n\r\n}\r\n\r\nexport function shallowReadOnly(target: object) {\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive', // 一个对象已经被代理过的标志\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n\r\nexport function toRaw<T>(observed: T): T {\r\n  // 如果传入的对象是一个响应式对象,例如reactive代理的响应式对象,可以访问该代理对象的'__v_raw'属性,这个属性会返回代理对象的原始对象\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  // 如果这里获取到了原始对象,但是这个原始对象还可能是一个响应式对象,因此需要递归的去调用toRaw方法去获取原始对象,直到真正的获取到了原始对象,此时原始对象身上没有'RAW'属性,因此返回这个原始对象\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  // 判断传入的原始数据是否为对象类型\r\n  // 如果传入的原始数据是对象类型,那么调用reactive去进行代理,这里reactive内部其实也是进行了相关的优化,如果一个原始值已经是被代理过的,那么会直接返回已经代理的对象,就不用重新去代理了\r\n  // 如果传入的原始数据不是对象类型,那么直接返回该数据\r\n  isObject(value) ? reactive(value as object) : value","import { isFunction, NOOP } from \"@vue/shared\"\r\nimport { Dep } from './dep'\r\nimport { isTracking, ReactiveEffect, trackEffects, trigger, triggerEffects } from './effect'\r\nimport { ReactiveFlags, toRaw } from \"./reactive\"\r\n\r\n\r\n/**\r\n * state.age 收集computed的副作用函数\r\n * \r\n * Myage.value 相当于计算属性收集最外层 effect\r\n * \r\n */\r\n// const Myage = computed(() => {\r\n//   return state.age + 19;\r\n// });\r\n// effect(() => {\r\n//   console.log(Myage.value); // 这样做的话相当于是个嵌套的effect,state.age收集了传给computed的副作用函数\r\n// });\r\n// // 需要通过.value 才执行\r\n// setTimeout(() => {\r\n//   state.age = 20;\r\n// }, 2000);\r\n\r\nexport type ComputedGetter<T> = (...args: any[]) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T> // 计算属性依赖于effect\r\n  public readonly __v_isRef = true\r\n  public _dirty = true  // 默认脏的\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly?: boolean,\r\n  ) {\r\n    // 这里将计算属性包成一个effect , getter相当于effect当中的副作用函数\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      // 稍后计算属性的值发生变化了,不要重新执行getter,而是走第二个函数\r\n      if (!this._dirty) {\r\n        this._dirty = true\r\n        // 重新执行最外层的effect\r\n        triggerEffects(this.dep)\r\n      }\r\n    })\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  // 取值时, 编译完就是Object.defineProperty\r\n  get value() {\r\n    if (isTracking()) { //是否是在effect中取值的\r\n      trackEffects(this.dep || (this.dep = new Set<ReactiveEffect>)) // 将外层的effect收集,相当于收集 computed.value -> Set(effect)\r\n    }\r\n\r\n    if (this._dirty) {\r\n      // 缓存结果 \r\n      this._dirty = false\r\n      this._value = this.effect.run()\r\n    }\r\n    return this._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue) // 如果修改计算属性的值就走setter\r\n  }\r\n}\r\n\r\nexport function computed<T>(getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>) {\r\n  // 判断传入的值是函数还是配置对象{get,set}\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = false // __DEV__\r\n      ? () => {\r\n        console.warn('Write operation failed: computed value is readonly')\r\n      }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  return new ComputedRefImpl(getter, setter)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import { Dep } from './dep'\r\nimport { isObject } from '@vue/shared'\r\nimport { reactive, toRaw, toReactive } from './reactive'\r\nimport { isTracking, trackEffects } from './effect'\r\n\r\n// ref入口函数\r\nexport function ref(value?: unknown) {\r\n  // 内部调用 createRef 函数，尾调用优化\r\n  return createRef(value, false)\r\n}\r\n\r\n// 真正创建 ref 实例的构造韩素华\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  // 判断传入的值是否为ref的实例，如果是直接返回\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n\r\n  // 如果不是，调用RefImpl构造函数，即创建ref实例 ， value,false\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\n\r\n// ref\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n\r\n  // 判断当前的实例是否为Ref对象\r\n  public readonly __v_isRef = true\r\n\r\n  // 这里ref 的 __v_isShallow 为false，用于判断是不是浅层次的响应式,即判断调用的函数时shallowRef 还是 ref\r\n  constructor(value: T, public readonly __v_isShallow: boolean) {\r\n\r\n    // 这里传入的值可能是一个reactive代理的响应式对象，因此通过toRaw方法，返回reactive代理的原始对象\r\n    this._rawValue = __v_isShallow ? value : toRaw(value) // 访问value['__v_raw]获取到原始对象并进行保存\r\n\r\n    // 对原始数据进行代理\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n\r\n    /**\r\n     *  执行到这里的时候,ref的实例已经是创建完成\r\n     *    让我们回顾整个创建的过程\r\n     *      1.首先我们是获取了传入的数据的原始数据\r\n     *      2.判断原始数据的数据类型是否为对象类型,如果是对象调用 reactive 进行代理,反之返回原始数据\r\n     *      3.将最终处理的数据保存在 _value 当中,基本数据类型就是基本数据类型,引用类型就通过 reactive 代理\r\n     */\r\n  }\r\n\r\n  /**\r\n   * 通过ref实例.value 获取到 _value 的值，_value值的类型根据 toReactive()的返回结果决定，\r\n   * 如果不是对象就是原始值。如果是对象，返回的是通过 reactive() 包装后的对象，也就是通过 Proxy() 代理的\r\n   */\r\n  get value() {\r\n    // 取值的时候依赖收集\r\n    if (isTracking()) {\r\n      trackEffects(this.dep || (this.dep = new Set()))\r\n    }\r\n    return this._value\r\n  }\r\n\r\n  // 在这里，无论是ref还是shallowRef的实例对象，都是同样的方式进行存储\r\n  set value(newVal) {\r\n    // 设置值的时候触发更新\r\n    if (newVal !== this._rawValue) {\r\n      this._rawValue = newVal\r\n      this._value = toReactive(newVal)\r\n      trackEffects(this.dep)\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport function shallowRef<T extends object>(\r\n  value: T\r\n): T extends Ref ? T : ShallowRef<T>\r\nexport function shallowRef<T>(value: T): ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  [RefSymbol]: true\r\n}\r\n\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\n\r\n// 如果传入ref的对象，已经是 ref 的实例\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}